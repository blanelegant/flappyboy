/*
 * FlappyBoy
 * by Blane Legant
 * ==========
 * A very simple Flappy Bird clone.
 * Specs:
 * Prest A or START to begin the game.
 * Then press A to flap your wings and avoid the pipes!
 * Thanks to
 *
 *
 */

 #include <stddef.h> // needed for NULL, probably other things
 #include <stdlib.h> // needed for malloc, etc
 #include "blegant3_lib.h" // some of my custom macro; includes "myLib.h"
 #include "strings.h" // text strings used in the game
 #include "img/sprites.h"
 #include "img/parallax-mountain.h"

 // --- GLOBAL VARIABLES -------------------------------------------------------

 // pointer to memory segment that is VRAM
 volatile unsigned short *videoBuffer = (volatile unsigned short *)0x6000000;

// shadow OAM, which we buffer updates into so we don't cause tearing
ObjAttr shadow[128];

 // set up global state machine enum
 enum GameState {
   STATE_STARTMENU,
   STATE_PAUSE,
   STATE_PLAYING,
   STATE_COLLIDED,
   STATE_GAMEOVER,
   STATE_NULL,
 };

 unsigned int prevKeyState; // used for de-bouncing with prevKeyState method

int main(void) {
  // --- BOOT -
  // copy sprite palette using DMA
  DMA[3].src = &sprites_palette; // from img/sprites.h
  DMA[3].dst = SPRITEPAL; // SPRITEPAL is already a pointer from myLib.h
  // SPRITES_PALETTE_LENGTH is generated by nin10kit and in img/sprites.h
  DMA[3].cnt = SPRITES_PALETTE_LENGTH | DMA_ON;

  // copy sprite tile data
  DMA[3].src = &sprites;
  DMA[3].dst = tile8_mem[5]; // aka a specific charblock in the memory buffer
  DMA[3].cnt = SPRITES_LENGTH | DMA_ON; // SPRITES_LENGTH from sprites.h

	// setup display mode and background
	REG_DISPCNT = MODE3 | BG2_ENABLE | SPRITES_DIMENSION_TYPE | OBJ_ENABLE;

  // set up state machine
  enum GameState state = STATE_STARTMENU; // initialize
  enum GameState prevState = STATE_NULL; // will be used later
  enum GameState nextState = STATE_NULL; // ^^

  // initialize our implementation of the basic text subsystem outlined in Tonc
  txt_init_std();

  // -- set up some global variables --
  // static int gravity = 1;
  unsigned int framecounter = 0; // used for timing

  // set up game objects
  // bird
  struct bird* birdy = (struct bird*) malloc(sizeof(struct bird));
  ObjAttr* birdySprite = &shadow[0];
  birdySprite->attr0 = (40 | ATTR0_8BPP | ATTR0_BLEND | BIRD_1_SPRITE_SHAPE);
  birdySprite->attr1 = (((240 / 2) - 8) | BIRD_1_SPRITE_SIZE);
  birdySprite->attr2 = (BIRD_3_ID);

  // pipe from above
  struct pipe* pipe_above = (struct pipe*) malloc(sizeof(struct pipe));

  ObjAttr* pipeAboveSprite = &shadow[1];
  pipeAboveSprite->attr0 =
    (0 | ATTR0_8BPP | ATTR0_BLEND | TOP_PIPE_SPRITE_SHAPE);
  pipeAboveSprite->attr1 = (240 | TOP_PIPE_SPRITE_SIZE );
  pipeAboveSprite->attr2 = (TOP_PIPE_ID);

// pipe from below
struct pipe* pipe_below = (struct pipe*) malloc(sizeof(struct pipe));

ObjAttr* pipeBelowSprite = &shadow[2];
pipeBelowSprite->attr0 =
  (128 | ATTR0_8BPP | ATTR0_BLEND | BOTTOM_PIPE_SPRITE_SHAPE);
pipeBelowSprite->attr1 = (240 | BOTTOM_PIPE_SPRITE_SIZE );
pipeBelowSprite->attr2 = (BOTTOM_PIPE_ID);

// hide all sprites (for now, at least at the beginning)
int i;
for(i = 0; i < 128; i++)
  shadow[i].attr0 = ATTR0_HIDE | shadow[i].attr0;

	// -- MAIN GAME LOOP ---------------------------------------------------------
	while(1) {
    // TODO: implement that other better vsync method
    waitForVBlank(); // wait for end of screen drawing
    switch(state) {

      case STATE_STARTMENU: // -------------------------------------------------
        if (prevState != STATE_STARTMENU) { // then it's the first frame

          // draw the background image
          drawImage3(0, 0, 240, 160, parallaxmountain);

          // draw text
          m3_puts(110, 80, text_start_game, WHITE);
        }

        if ((key_down((BUTTON_A) | (BUTTON_START))) == TRUE) {
          nextState = STATE_PLAYING; // transition to playing mode
        }

      break;

      case STATE_PLAYING: // ---------------------------------------------------
      // if this is the first frame of the new state
        if (prevState != STATE_PLAYING) {
          // perform initialization steps

          // overwrite menu screen
          drawImage3(0, 0, 240, 160, parallaxmountain);

          // unhide birdy sprite
          birdySprite->attr0 = (ATTR0_REG | (birdySprite->attr0 & ~0x0300));
          pipeAboveSprite->attr0 =
            (ATTR0_REG | (pipeAboveSprite->attr0 & ~0x0300));
          pipeBelowSprite->attr0 =
            (ATTR0_REG | (pipeBelowSprite->attr0 & ~0x0300));

          // set bird/pipe defaults
          pipe_below->x = 240;
          pipe_below->type = 0;

          pipe_above->x = 240;
          pipe_above->type = 1;

          birdy->y = 160 - 40; // reset
          birdy->dy = 0; // clear velocity
        }

          // only perform physics updates every so often
          if(framecounter % 5 == 0) {
            if (birdy->dy > -15) { // max velocity
              birdy->dy--; // "force of gravity"
            }
          }

          // update bird animation frame, if we're descending
          if (birdy->dy < 0) {
            birdySprite->attr2 = (BIRD_3_ID | (birdySprite->attr2 & ~0x03FF));

          } else if (birdy->dy == 0) {
            birdySprite->attr2 = (BIRD_1_ID | (birdySprite->attr2 & ~0x03FF));

          } else {
            birdySprite->attr2 = (BIRD_2_ID | (birdySprite->attr2 & ~0x03FF));
          }

          // update game object position
          birdy->y += birdy->dy; // position += volicity

          if (framecounter % 2 == 0) {
            if (pipe_above->x <= 0) {
              pipe_above->x = 240;
            } else {
              pipe_above->x--;
            }
          }

          if (framecounter % 3 == 0) {
            if (pipe_below->x <= 0) {
              pipe_below->x = 240;
            } else {
              pipe_below->x--;
            }
          }

          // --- COLLISION DETECTION -------------------------------------------

          // check if we've hit the floor/ground/gone off screen
          if (birdy->y <= 0) {
            nextState = STATE_GAMEOVER; // jump straight to game over state
          }

          // now, check if we're within the above pipe...
          // unfortunate use of magic number heres
          if ((birdy->y >= 128)
            && ((pipe_above->x <= (120 + 16) && !(pipe_above->x < (98 + 16))))) {
            nextState = STATE_COLLIDED;
          }

          // ... or the below one
          if ((birdy->y <= 32)
            && ((pipe_below->x <= (120 + 16) && !(pipe_below->x < (98 + 16))))) {
            nextState = STATE_COLLIDED;
          }

          // finally, update position attributes of OAM game objects
          birdySprite->attr0 = (((160 - birdy->y) & 0xFF)
            | (birdySprite->attr0 & 0xFF00));
          pipeAboveSprite->attr1 = ((pipe_above->x & 0xFF)
            | (pipeAboveSprite->attr1 & 0xFF00));
          pipeBelowSprite->attr1 = ((pipe_below->x & 0xFF)
            | (pipeBelowSprite->attr1 & 0xFF00));

          // for some reason, enabling the below snippet causes all input to fail:

          // if (key_down(BUTTON_START)) {
          //   nextState = STATE_PAUSE;
          // }

          // check if the player has pressed A
          if (key_down(BUTTON_A)) {
            birdy->dy = 4; // set some upward velocity (NOTE: not +=)

            // switch to frame 1 so it looks like we're flapping down
            birdySprite->attr2 = (BIRD_1_ID | (birdySprite->attr2 & ~0x03FF));
          }

        break;

        case STATE_PAUSE: // ---------------------------------------------------
          // if this is the first frame of the new state
          if (prevState != STATE_PAUSE) {
            // perform initialization steps
            // TODO: draw "pause" test on the screen
            m3_puts(120, 80, text_paused, WHITE);
          }

          nextState = STATE_PAUSE;

          if (key_down(BUTTON_START)) {
            nextState = STATE_PLAYING;
            drawImage3(0, 0, 240, 160, parallaxmountain);
          }
        break;

      case STATE_COLLIDED: // --------------------------------------------------
        // if this is the first frame of the new state
        if (prevState != STATE_COLLIDED) {
          // no initialization steps needed
        }

        // freefall like above
        // should probably be wrapped up into a function
        if(framecounter % 5 == 0) {
          if (birdy->dy > -15) { // max velocity
            birdy->dy--; // "force of gravity"
          }
        }

        birdy->y += birdy->dy; // position += velocity

        birdySprite->attr0 = // update y-position attribute
          (((160 - birdy->y) & 0xFF) | (birdySprite->attr0 & 0xFF00));

        // when we hit the ground, switch to game over state
        if (birdy->y <= 0) {
          nextState = STATE_GAMEOVER;
        }
      break;

      case STATE_GAMEOVER: // --------------------------------------------------
        // if this is the first frame of the new state
        if (prevState != STATE_GAMEOVER) {
          // perform initialization steps
          m3_puts(110, 80, text_game_over, WHITE);
          m3_puts(130, 84, text_press_a, WHITE);
        }

        if (key_down(BUTTON_A | BUTTON_START)) {
          nextState = STATE_STARTMENU; // transition to playing mode
        }
      break;

      case STATE_NULL:
      break;
    }

    // -- methods done every frame no matter machine state ---------------------

    // -- take care of updating sprites --
    // copy sprite tile data
    DMA[3].src = shadow;
    DMA[3].dst = OAM_MEM; // aka a specific charblock in the memory buffer
    DMA[3].cnt = ((4 * 128) | DMA_ON); // SPRITES_LENGTH from sprites.h

    // determine next state and record current as previous
    prevState = state; // last thing: store current state as previous...
      if (nextState != STATE_NULL) {
        state = nextState; // ...set our current state to what we've defined as next
      }
    // we generally want to preserve the previous state

    // finally, increment frame framecounter
    framecounter++;
  }
  return 0;
}

void waitForVBlank(void) {
  while(*SCANLINECOUNTER >= 160); // wait for end of overscan, if we need to
  while(*SCANLINECOUNTER < 160); // wait till we next *begin* overscan
}

void drawImage3(int r, int c, int width, int height, const u16* image) {
  // uses DMA!
  int x = 0;
  for (x = 0; x < height; x++) {
    DMA[3].src = &image[OFFSET(x, 0, width)];
    DMA[3].dst = &videoBuffer[OFFSET(r + x, c, 240)];
    DMA[3].cnt = (width) | DMA_ON;

  }
}

// generic setPixel function (for testing purposes)
void setPixel(int row, int col, u16 color) {
  videoBuffer[OFFSET(row, col, 240)] = color;
}

// detects if key is down and should take care of debouncing
int key_down(u8 button) {
  if (((KEY_DOWN_NOW(button)) != 0) && ((prevKeyState & button) == 0)) {
    prevKeyState = ~(BUTTONS);
    return TRUE;
  } else {
    prevKeyState = ~(BUTTONS);
    return FALSE;
  }
}
